/**
 * @file bg_sub.cpp
 * @brief Background subtraction tutorial sample code
 * @author Domenico D. Bloisi
 */

//opencv
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv\cv.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat bgImage;
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard

const string windowname_Frame = "Frame";
const string windowname_MOG = "FG Mask MOG";
const string windowname_MOG2 = "FG Mask MOG 2";
const string windowname_background = "background";



const double learning_rate = 0.1;

/** Function Headers */
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void OptflowImage(char* directory);

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bs {-vid <video filename>|-img <image filename>}"                         << endl
    << "for example: ./bs -vid video.avi"                                           << endl
    << "or: ./bs -img /data/images/1.png"                                           << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}

vector<Mat> load_Images(const char* directory)
{
	vector<Mat> out;
	std::stringstream ss;
	ss << directory << "\\%010d.png"/*"\\0000000099.png"*/;
    cv::VideoCapture sequence(ss.str());
    if (!sequence.isOpened())
    {
        std::cerr << "Failed to open image sequence!\n" << std::endl;
		out.clear();
		return out;
    }

    cv::Mat image;

    //! Load all images sequentially into vector imgs
    for(;;)
    {
        sequence >> image;

        if(image.empty())
        {
            std::cout << "End of Sequence" << std::endl;
            break;
        }

        out.push_back( image.clone() );
    }
	return out;
}


/**
 * @function main
 */
int main(int argc, char* argv[])
{
    //print help information
    help();

    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }

	int windowHeight = 350;
	int windowWidth = 900;

    //create GUI windows
	namedWindow(windowname_Frame,CV_WINDOW_KEEPRATIO);
	resizeWindow(windowname_Frame,windowWidth,windowHeight);
    namedWindow(windowname_MOG2,CV_WINDOW_NORMAL);
	resizeWindow(windowname_MOG2,windowWidth,windowHeight);
	namedWindow(windowname_background,CV_WINDOW_NORMAL);
	resizeWindow(windowname_background,windowWidth,windowHeight);

    //create Background Subtractor objects
	pMOG2 = new BackgroundSubtractorMOG2(100,16,false); //MOG2 approach

    if(strcmp(argv[1], "-vid") == 0) {
        //input data coming from a video
        processVideo(argv[2]);
    }
    else if(strcmp(argv[1], "-img") == 0) {
        //input data coming from a sequence of images
        processImages(argv[2]);
		//OptflowImage(argv[2]);
    }
    else {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}

/**
 * @function processVideo
 */
void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        //update the background model
		pMOG2->operator()(frame, fgMaskMOG2, learning_rate);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(CV_CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        //show the current frame and the fg masks
		imshow(windowname_background, frame);
		imshow(windowname_MOG2, fgMaskMOG2);
		imshow(windowname_background,bgImage);
        //get the input from the keyboard
        keyboard = waitKey( 30 );
    }
    //delete capture object
    capture.release();
}

int numDigits(int number)
{
    int digits = 0;
    if (number < 0) digits = 1; // remove this line if '-' counts as a digit
    while (number) {
        number /= 10;
        digits++;
    }
    return digits;
}

string createPrefix(int frameNr)
{
	int filenameSize = 10;
	stringstream oss;
	oss << frameNr;
	string output = oss.str();
	while(output.length() < filenameSize)
	{
		output = '0' + output;
	}
	return output;
}

//void generate_Framenumber(const char* filename, int* frameNumber, string* nextFilename)
//{
//	string fn(filename);
//	size_t index = fn.find_last_of("/");
//    if(index == string::npos) {
//        index = fn.find_last_of("\\");
//    }
//    size_t index2 = fn.find_last_of(".");
//    string prefix = fn.substr(0,index+1);
//    string suffix = fn.substr(index2);
//    string frameNumberString = fn.substr(index+1, index2-index-1);
//    istringstream iss(frameNumberString);
//    int frameNumberI = 0;
//    iss >> *frameNumber;
//	ostringstream oss;
//    oss << (frameNumber + 1);
//	string nextFrameNumberString = /*oss.str();*/ createPrefix(*frameNumber+1);
//    string nextFrameFilename = prefix + nextFrameNumberString + suffix;
//	nextFilename = nextFrameFilename.c_str();
//}
//
//string generate_nextFilename(int frameNumber)
//{
//	
//}

// returns a pointer to a vector with filenmame infos of filename fn
// vector consits of prefix, suffix and filenumber
vector<string>* filename_getInfos(string fn)
{
	vector<string>* out = new vector<string>;
	size_t index = fn.find_last_of("/");
    if(index == string::npos) {
        index = fn.find_last_of("\\");
    }
    size_t index2 = fn.find_last_of(".");
	out->push_back(fn.substr(0,index+1));
    out->push_back(fn.substr(index2));
	out->push_back(fn.substr(index+1, index2-index-1));
	return out;
}

void drawFrameNumber(string fn)
{
	vector<string>* fnInfos = filename_getInfos(fn);
	string prefix = fnInfos->at(0);
    string suffix = fnInfos->at(1);
    string frameNumberString = fnInfos->at(2);
    istringstream iss(frameNumberString);
    int frameNumber = 0;
    iss >> frameNumber;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                cv::Scalar(255,255,255), -1);
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
	delete fnInfos;
}

string filename_getNext(string fn)
{
	vector<string>* fnInfos = filename_getInfos(fn);
	string prefix = fnInfos->at(0);
	string suffix = fnInfos->at(1);
	string frameNumberString = fnInfos->at(2);
	istringstream iss(frameNumberString);
	int frameNumber = 0;
	iss >> frameNumber;
    //## search for the next image in the sequence
    ostringstream oss;
    oss << (frameNumber + 1);
	string nextFrameNumberString = /*oss.str();*/ createPrefix(frameNumber+1);
    return prefix + nextFrameNumberString + suffix;
}

void findBigBlobs(InputOutputArray image, double thresh = 90)
{
	// threashold specifying minimum area of a blob

	vector<vector<Point>> contours;
	vector<Vec4i> hierarchy;
	vector<int> small_blobs;
	double contour_area;
	Mat temp_image;
	
	// find all contours in the binary image

	findContours(image, contours, hierarchy, CV_RETR_CCOMP,
													  CV_CHAIN_APPROX_SIMPLE);

	// Find indices of contours whose area is less than `threshold` 
	if ( !contours.empty()) {
		for (size_t i=0; i<contours.size(); ++i) {
			contour_area = contourArea(contours[i]) ;
			if ( contour_area < thresh)
				small_blobs.push_back(i);
			drawContours(image, contours, i, cv::Scalar(255,255,255), 
													 CV_FILLED, 8);
		}
	}

	// fill-in all small contours with zeros
	for (size_t i=0; i < small_blobs.size(); ++i) {
		drawContours(image, contours, small_blobs[i], cv::Scalar(0), 
													 CV_FILLED, 8);
	}
}

void Dilation(InputArray src, OutputArray dst, int size,int kernelType, int iterations = 1)
{
	Mat element = getStructuringElement( kernelType,
						Size( 2*size + 1, 2*size+1 ),
						Point( size, size ) );
	/// Apply the dilation operation 'iterations' times
	for(int i = 0; i<iterations;++i)
	{
		if(i < 1)
		{
			dilate(src, dst, element);
		}
		else
		{
			dilate(dst, dst, element);
		}
	}
}

void Erosion(InputArray src, OutputArray dst, int size,int kernelType, int iterations = 1)
{
	Mat element = getStructuringElement( kernelType,
						Size( 2*size + 1, 2*size+1 ),
						Point( size, size ) );
	/// Apply the erosion operation 'iterations' times
	for(int i = 0; i<iterations;++i)
	{
		if(i < 1)
		{
			erode(src, dst, element);
		}
		else
		{
			erode(dst, dst, element);
		}
	}
}

void track_LK(InputArray gray, InputArray mask)
{
	const int maxCorners = 15;
	const float qualityLevel = 0.001;
	const float minDistance = 20;
	std::vector< cv::Point2f > corners;
	//## find features to track with LK optFlow
	goodFeaturesToTrack(gray,corners, maxCorners, qualityLevel, minDistance,mask,3,false,0.04);

	//## ## Debug output of found features
	Mat cornerOutput = frame.clone();
	const char* windowName_corners = "corners";
	namedWindow(windowName_corners, CV_WINDOW_KEEPRATIO);

	for( size_t i = 0; i < corners.size(); i++ )
	{
		cv::circle( cornerOutput, corners[i], 10, cv::Scalar( 255. ), -1 );
	}

	cv::imshow(windowName_corners, cornerOutput);
}

/**
 * @function processImages
 */
void processImages(char* fistFrameFilename) {

	//########## Read frame ################

    //read the first file of the sequence
    frame = imread(fistFrameFilename);
    if(!frame.data){
        //error in opening the first image
        cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
        exit(EXIT_FAILURE);
    }


	//########## declarations ################
	Mat gray;
	cvtColor(frame,gray,CV_BGR2GRAY);

	Mat eroded(frame.size(),CV_8UC1);
	Mat opened(frame.size(), CV_8UC1);

	bgImage = Mat(frame.size().height,frame.size().width,CV_64F, cvScalar(0.));
    //current image filename
    string fn(fistFrameFilename);


	//############ Frame Loop ###############
    //read input data. ESC or 'q' for quitting
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
		
		//########  mask generation and refinement  ###############
		//update the background model
		pMOG2->operator()(frame, fgMaskMOG2, learning_rate);
		
		//## ## Debugwindows for morphilogic operations	
		const char* windowName_erode = "erded";
		namedWindow(windowName_erode,CV_WINDOW_KEEPRATIO);
		const char* windowName_opened = "opened";
		namedWindow(windowName_opened, CV_WINDOW_KEEPRATIO);

		int erosion_size = 5;
		int morphIterations = 7;

		//## Opening to refine mask
		//Erosion(fgMaskMOG2,eroded,erosion_size,MORPH_RECT);
		cv::imshow(windowName_erode,eroded);
		/*Dilation(eroded,opened,erosion_size,MORPH_ELLIPSE,morphIterations);
		Erosion(eroded,opened,erosion_size,MORPH_ELLIPSE,morphIterations);*/
		
		opened = fgMaskMOG2.clone();
		findBigBlobs(opened);
		Dilation(opened,opened,erosion_size,MORPH_ELLIPSE,morphIterations);
		Erosion(opened,opened,erosion_size,MORPH_ELLIPSE,morphIterations);

		cv::imshow(windowName_opened,opened);


		//########### Tracking ################
		track_LK(gray,opened);

		//## get Backgroundimage and show results
		pMOG2->getBackgroundImage(bgImage);
		drawFrameNumber(fn);
        //## show the current frame and the fg masks
        imshow("Frame", frame);
       // imshow("FG Mask MOG", fgMaskMOG);
        imshow("FG Mask MOG 2", fgMaskMOG2);
		imshow("background",bgImage);

        //## get the input from the keyboard
        keyboard = waitKey( 50 );

		string nextFrameFilename = filename_getNext(fn);
        //## read the next frame
        frame = imread(nextFrameFilename);
        if(!frame.data){
            //## error in opening the next image in the sequence
            cerr << "Unable to open image frame: " << nextFrameFilename << endl;
            exit(EXIT_FAILURE);
        }
        //## update the path of the current frame
        fn.assign(nextFrameFilename);
    }
}


void OptflowImage(char* directory)
{
	const string windowname_optFlow = "Optical flow Test";
	const string windowname_Frame = "Video Frame";

	namedWindow(windowname_optFlow,CV_WINDOW_KEEPRATIO);
	namedWindow(windowname_Frame,CV_WINDOW_KEEPRATIO);

	vector<Mat> frames = load_Images(directory);
	if(frames.empty())
	{
		return;
	}
	vector<Mat>::const_iterator frameIteraor = frames.begin();
	Mat previousFrame = *frameIteraor;
	Mat currentFrame = *(++frameIteraor);
	Mat flow;
	Mat prv;
	Mat nxt;
	for(;frameIteraor != frames.end(); ++frameIteraor)
	{
		//imshow(windowname_optFlow,previousFrame);
		imshow(windowname_Frame,previousFrame);
		previousFrame = currentFrame;
		currentFrame = *frameIteraor;

		cvtColor(previousFrame,prv, CV_BGR2GRAY);
		cvtColor(currentFrame,nxt, CV_BGR2GRAY);
		
		calcOpticalFlowFarneback(prv, nxt, flow,0.1,2,6,4,7,1.1,0);
		//calcOpticalFlowFarneback(prv, nxt, flow,0.8,14,6,14,7,1.1,0);

		//extraxt x and y channels
		cv::Mat xy[2]; //X,Y
		cv::split(flow, xy);

		//calculate angle and magnitude
		cv::Mat magnitude, angle;
		cv::cartToPolar(xy[0], xy[1], magnitude, angle, true);

		//translate magnitude to range [0;1]
		double mag_max;
		cv::minMaxLoc(magnitude,NULL,&mag_max,NULL);
		magnitude.convertTo(magnitude, -1, 1.0/mag_max);

		//build hsv image
		cv::Mat _hsv[3], hsv;
		_hsv[0] = angle;
		_hsv[1] = Mat::ones((angle.size()).height,angle.size().width, CV_32F);
		_hsv[2] = magnitude;
		cv::merge(_hsv, 3, hsv);

		//convert to BGR and show
		Mat bgr;//CV_32FC3 matrix
		cv::cvtColor(hsv, bgr, cv::COLOR_HSV2BGR);
		cv::imshow(windowname_optFlow, bgr);

		char key = (char)cv::waitKey(40);
        if(key == 'q' || key == 'Q' || key == 27)
            break;
	}
}
